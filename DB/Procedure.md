## 프로시저
- 데이터베이스에서 SQL 작업 중, 하나의 쿼리문으로 원하는 결과를 얻기 힘든 상황에서 사용.
- 즉, 여러줄의 쿼리문을 한 번의 요청으로 실행할 수 있게 사용하는 것.
- 인자 값만 상황에 따라 바뀌고 동일한 로직의 복잡한 쿼리문을 필요할 때마다 작성한다면 비효율적인 처리를 대체할 수 있다.
- 복잡한 트랜잭션 관리나 데이터 조작이 필요한 경우에 유용하게 사용될 수 있다.


## 호출 예시
```sql
CREATE OR REPLACE PROCEDURE test( name OUT VARCHAR2 ) 
IS
BEGIN 
	name := 'Gyoogle'
END;

DECLARE
out_name VARCHAR2(100);

BEGIN
test(out_name);
dbms_output.put_line('내 이름은 '||out_name);
END;
```

## 장점
- 최적화 & 캐시
    - 프로시저의 최초 실행 시, 최적화 상태로 컴파일이 되며 그 이후 프로시저 캐시에 저장된다.
    - 만약 해당 프로세스가 여러번 사용될 때, 다시 컴파일 작업을 거치지 않고 캐시에서 가져오게 된다.
- 유지보수
    - 작업이 변경될 때, 다른 작업은 건드리지 않고 프로시저 내부만 수정하면 된다.
- 보안
    - 프로시저 내에서 참조 중인 테이블의 접근을 막을 수 있다.
    - 프로시저 내부에서 민감한 로직을 숨길 수 있어 보안성이 높아진다.
    - 데이터베이스 사용자에게 직접 테이블 접근 권한을 주지 않고, 프로시저 실행 권한만 부여할 수도 있다. 이를 통해 데이터 제어가 더 용이해진다.

    
## 단점
- 버전 관리 문제
    - 코드와 달리, 프로시저는 버전 관리가 어렵다. 즉, 변경사항에 대한 히스토리 파악이 힘들다.
- 디버깅 어려움
    - 프로시저 내부에서 발생하는 문제를 추적하고 수정하기가 어렵다.
- 이식성 부족
    - 프로시저는 특정 데이터베이스에 종속적인 경우가 많아, 다른 데이터베이스 시스템으로 이식하는 것이 어려울 수 있다.
    - 예를 들어, mysql과 oracle 간의 프로시저 구문이 다를 수 있다.